## 原码，反码，补码和移码
|             | 1的二进制表示 | -1的二进制表示 | 1+（-1）的二进制加法运算|
| :--------:  | :--------:   |:---------:     |:---------:            |
| **原码**    | 0000 0001    | 1000 0001      | 1000 0010 = -2(D)     |
| **反码**    | 0000 0001    | 1111 1110      | 1111 1111 = -0(D)     |
| **补码**    | 0000 0001    | 1111 1111      | 0000 0000 = 0(D)      |
| **移码**    | 1000 0001    | 0111 1111      | 0000 0000             |
### 原码
计算机中的信息都是以二进制的形式表示的，而数值有正负之分，计算机就用一个数的最高位来存放符号，其中正数为0，负数为1，这就是**原码**。
假设机器能处理的位数为8，在没有负数的情况下，可以表示的整数范围是[0,255]，共256个数，而现在需要存放正数和负数，所以需要在最高位存一个符号位，其中0代表正数，1代表负数，因此原码**0000 0000**代表 **+0**，原码**1000 0000**代表 **-0**，所以表示正负的原码范围为[-127,-0]∪[+0,127]，共255个数。
使用原码进行算术运算，会发现对于带符号位的原码进行乘除运算时结果正确，而在做加减运算的时候就出现了问题。

```
1(D) - 1(D) = 1(D) + (-1)(D) = 0(D)
0000 0001(B,原) + 1000 0001(B,原) = 1000 0010(B,原) = -2(D)
```

### 反码
因为在两个整数的加法运算中没有问题，于是就发现问题出现在带符号位的负数身上，对除符号位外的其余各位逐位取反就产生了**反码** ，而正数的反码和原码保持一致。**反码的取值空间和原码相同且一一对应**。
使用反码进行算术运算。

```
1(D) - 1(D) = 1(D) + (-1)(D) = 0(D)
0000 0001(B,反) + 1111 1110(B,反) = 1111 1111(B,反) = 1000 0000(B,原) = -0(D)

1(D) - 2(D) = 1(D) + (-2)(D) = -1(D)
0000 0001(B,反) + 1111 1101(B,反) = 1111 1110(B,反) = 1000 0001(B,原) = -1(D)
```

### 补码
由上面的反码运算可知，正常的加减运算没问题，但是+0和-0的问题还没有解决，因为零没有正负之分。于是变引入了**补码**这个概念。其中补码的规则就是，负数的补码为负数的反码加一，而正数的补码和反码保持一致。在补码中用-128代替了-0，所以补码的表示范围为[-128,127],共256个。
使用补码进行算术运算：

```
1(D) - 1(D) = 1(D) + (-1)(D) = 0(D)
0000 0001(B,补) + 1111 1111(B,补) = 0000 0000(B,补) = 0000 0000(B,原) = 0(D)

1(D) - 2(D) = 1(D) + (-2)(D) = -1(D)
0000 0001(B,补) + 1111 1110(B,补) = 1111 1111(B,补) = 1000 0001(B,原) = -1(D)
```

### 移码
补码的符号位取反
​移码=真值 + 偏移量
​移码长用来比较大小，一般会把浮点数的阶码用移码表示，说的通俗一点，你把数值用移码表示出来可以一眼看出他们的大小。这样很容易判断阶码的大小，移码可用于简化浮点数的乘除法运算。

### 原码，反码，补码和移码
反码：解决负数加法运算的问题，将减法运算转换为加法运算，从而简化运算规则
​补码：解决负数加法运算正负零问题，弥补了反码的不足。
​总之，反码与补码都是为了解决负数运算问题，跟正数没有什么关系，因此，不管是正数还是正小数，原码，反码，补码全部都相同。

## 定点数和浮点数
### [定点数](https://zhuanlan.zhihu.com/p/338588296)
#### 定点数的定义 
定点数：**约定计算机中小数点的位置**，且这个位置固定不变，小数点前，后的数字，分别用二进制表示，然后组合起来就可以把这个数字在计算机中存储起来，这种表示方式叫做**定点**表示法，用这种方法表示的数字叫做**定点数**。
也就是说**定**是指固定的意思，**点**是指小数点，***小数点位置固定*** 即定点数名字的由来。

####  定点数表示整数和纯小数
对于纯整数100，由于小数点固定在最高位，同样以1个字节（8bit）表示，用定点数表示如下：

```
100(D) = 01100100(B)
```

对于纯小数0.125，由于小数点固定在最高位，同样以1个字节（8bit）表示，用定点数表示如下：

```
0.125(D) = 0.00100000(B)
```

以上2种情况，按照十进制转二进制规则，即可得到结果。
#### 定点数表示整数+小数
我们首先约定小数点的位置，以1个字节（8bit）为例，我们约定**前五位**表示整数部分，**后三位**表示小数部分。
对于数字1.5，用定点数表示如下：

```
1.5(D) = 0001 100(B)
```

对于数字25.125，用定点数表示如下：

```
25.125(D) = 11001 001(B)
```

#### 定点数的问题
我们约定前5位表示整数部分，后3位表示小数部分，此时这个整数部分的二进制最大值只能是11111，即十进制的31，小数部分的二进制最大只能表示0.111，即10进制的0.875。
如果我们想要表示更大范围的值，怎么办？
1. 扩大bit的宽度：使用2个字节，3个字节...这样整数部分和小数部分宽度增加，表示范围也就变大了
2. 改变小数点的位置：小数点向后移动，整体的数字范围就会扩大，但是小数部分的精度就会越来越低

由此我们发现，不管如何约定小数点的位置，都会存在以下问题：
- 数值的表示范围有限（小数点越靠左，整个数值范围越小）
- 数值的精度范围有限（小数点越靠后，数值精度越低）

总的来说，就是用定点数表示的小数，不仅数值的范围表示有限，而且其精度也很低，所以在计算机中，我们一般使用**浮点数**来表示小数。
虽然定点数表示数字，存在以上说的这些问题，但也只是在表示小数的场景下。如果只是用于表示整数，还是非常方便的。所以，现代计算机一般使用定点数来表示整数，而对于高精度的小数，通常用浮点数表示。
### [浮点数](https://zhuanlan.zhihu.com/p/339949186)
#### 浮点数的定义
定点数的**定点**指的是约定小数点位置固定不变。而浮点数的**浮点**就是指，其小数点的位置是可以**漂浮不定**的。
#### 浮点数表示数字
浮点数表示数字：$ V = (-1)^S * M * R^E $
其中各个变量的含义如下：

- S:符号位，取值0或者1，决定一个数的正负。
- M:尾数，用小数表示。
- R:基数，表示十进制数，R就是10。表示二进制数，R就是2。
- E:指数，用整数表示。
如果我们要在计算机中，用浮点数表示一个数字，只需要确定上面的这几个变量即可。
#### 计算机浮点数标准IEEE754
1985年，IEEE组织推出了浮点数标准，就是我们经常听到的IEEE754浮点标准，这个标准统一了浮点数的表示形式，并提供了2种浮点格式：
- 单精度浮点数float：32位，符号位S占1bit，指数E占8bit，尾数M占23bit
- 双精度浮点数double：64位，符号位S占1bit，指数E占11bit，尾数M占52bit

为了使其表示的数字范围，精度最大化，浮点数标准还对指数和尾数进行了规，定：
- 尾数M的第一位总是1，因此这个1可以省略不写，它是一个**隐藏位**，这样单精度23位尾数就可以表示24位有效数字，双精度52位尾数可以表示53位有效数字。
- 尾数E是个无符号整数，表示float时，一共占8bit，所以它的取值范围为0 ~ 255。但因为指数可以是负数，所以规定在存入E时在它原本的值上加上一个**中间数**127，这样E的取值范围为-127 ~ 128。表示double时，一共占11bit，存入E时加上中间数1023，这样取值范围为-1023 ~ 1024.

除了规定尾数位和指数位，还做了以下规定：
- 指数E非全0且非全1：规格化数字，按上面的规则正常计算
- 指数E全0，尾数非0：非规格化数，尾数隐藏位不再是1，而是0（M=0.xxxx），这样可以表示0和很小的数
- 指数E全1，尾数全0：正无穷大/负无穷大（正负取决于S符号位）
- 指数E全1，尾数非0：NaN(Not a Number)
  

使用浮点数标准，把25.125转换为标准的float浮点数：
1. 整数部分：`25(D)=11001(B)`
2. 小数部分：`0.125(D)=0.001(B)`
3. 用基数为2的浮点数表示：`25.125(D)=11001.001(B)=1.1001001*2^4(B)`

所以S=0,尾数M=1.001001=001001(去掉1，隐藏位)，指数E=4+127(中间数)=131(D)=10000111(B)
如果用double表示，和这个规则类似，指数位E用11bit填充，尾数位M用52bit填充即可。

#### 为什么IEEE754阶码E使用移码
为了简化浮点数的比较，故我们使用移码来表示阶码位，这样就不至于在比较时去考虑两次符号位了。

####  浮点数精度损失问题
十进制整数转换为二进制整数采用"除2取余，逆序排序"法。
十进制小数转换成二进制小数采用"乘2取整，顺序排列"法。

```
0.2 = (0.0 0110 0110 ...)
0.2 * 2 = 0.4 => 取出整数部分0

0.4 * 2 = 0.8 => 取出整数部分0
0.8 * 2 = 1.6 => 取出整数部分1
0.6 * 2 = 1.2 => 取出整数部分1
0.2 * 2 = 0.4 => 取出整数部分0

0.4 * 2 = 0.8 => 取出整数部分0
0.8 * 2 = 1.6 => 取出整数部分1
0.6 * 2 = 1.2 => 取出整数部分1
0.2 * 2 = 0.4 => 取出整数部分0
```

因为十进制的0.2无法精确转换成二进制小数，而计算机表示一个数字时，宽度是有限的，无线循环小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。

#### 浮点数的范围和精度
单精度浮点float可以表示的范围：
它能表示的最大二进制数为，$1.11111111111111111111111*2^{127}$(小数点后面有23个1),而二进制 $1.11111111111111111111111 \approx 2$,所以float能表示的最大数为 $ 2^{128} = 3.4 * 10^{38} $,即float的表示范围为：$ -3.4*10^{38} \backsim 3.4*10^{38}$。
单精度浮点float可以表示的精度：
float能表示的最小二进制数为，$0.00000000000000000000001$(小数点后22个0，1个1)，用十进制数表示就是 $1/2^{23}$。
双精度浮点double的范围和精度的计算与单精度浮点float类似。
从以上分析可知，虽然浮点数的范围和精度也有限，但其范围和精度都已非常大，所以在计算机中，对于小数的表示我们通常会使用浮点数来存储。